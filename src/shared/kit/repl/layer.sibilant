(namespace repl)

(include "../../../../headers/repl.sibilant"
         "../../../../headers/interface.sibilant"
         "../../../../headers/core")

(import-namespace core)
(import-namespace interface )
(import-namespace events)

(import Interface "../interface/index.js")
(import Actor "../actor/index.js")
(import emit "../events/index.js")

(var curry R.curry)

(define Layer Actor

  (init ( types (members (.map types (=> (t) ((create t))))))
        (doc-string "repl.Layer.init" "types"
                   "Instantiate member actors for each type and initialize the layer.")
        (each types (t i) (set this t.symbol (get members i)))
        (.call Actor.init this))

  (gett assign-handlers
        (=> (a i)
            (doc-string "repl.Layer.assign-handlers" "actor index"
                       "Connect message handlers between adjacent actors in the layer.")
            (var members this.members)
            (pipe a
                  (.on 'message (R.pipe
                                 (send-to (get this.members (+ i 1)))))
                  (bubble  this 'error))))

  (def-generic *send (d members)
    (doc-string "repl.Layer.*send" "data members"
               "Send a message to the first actor in the layer.")
    (.send (first members) d))

  (def-generic start (members)
    (doc-string "repl.Layer.start" "members"
               "Start the layer by wiring handlers and bubbling messages from the last actor.")

    (fluently

     (var last (last members)
          inner (.slice members 0 -1))

     (.for-each inner this.assign-handlers)

     (bubble  last this 'message )))

  (def of (types)
    (doc-string "repl.Layer.of" "types"
               "Create a new Layer composed of the given actor types.")
    (extend this (lit types))))

(export Layer)


