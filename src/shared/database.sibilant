(import Interface "/shared/kit/interface/index.js")
(import Event-emitter "/shared/kit/events/index.js")
(def-lit-macro def-async (name args ...body)
  [" async "name  `(parenthetic (comma @args.contents))
            `(curly (do-block ...@body))])
(define Collection Interface
  (init (name database))
  (def *state-transaction ()
    )
  (def get (key))
  (def delete (key))
  (def set (key value)))

(define Database Interface

  (init (name (events ((create Event-emitter)))))
  (cached db (.start this))
  (gett version-key (+ this.name 'Version))
  (gett version (or (.get-item local-storage this.version-key) 1))
  (sett version v (.set-item local-storage this.version-key v))
  (gett collection-names-key  (+ this.name 'Collection-names))
  (sett collection-names v
        (assign this.version (+ 1 this.version))
        (.set-item local-storage this.collection-names-key
                   (JSON.stringify v)))
  (gett collection-names
        (JSON.parse (.get-item local-storage this.collection-names-key)))

  (def add-collection (name)
    (const names this.collection-names)
    (if! (.includes names name) (return))
    (.push names name)
    (assign this.collection-names names))
  (def upgrade (db)
    (each this.collections (c)
          (if (not (.includes db.object-store-names c))
              (.create-object-store db c (lit (key-path 'save-index))))))
  (def remove-collection (name)

    (const names this.collection-names)
    (if! (not (.includes names name))
         (throw (new Error "Attempting to remove a collection that doesn't exist")))
    (.push names name)
    (assign this.collection-names names))
  (def-async* get-cursor (collection-name )

    (const db (await this.db))
    (const transaction (.transaction db [collection-name] 'readwrite))
    (const object-store (.object-store transaction collection-name))
    (const cursor (.open-cursor object-store))
    (var looping? true)
    (const get-next (-> (make-promise
                         (def cursor.onsuccess (e) (success e.target.result)))))
    (var p  (get-next))
    (while! true
            (const c (await p))
            (if! (not c)  break)
            (yield c)
            (assign p (get-next))
            (.continue c))
    null
    )

  (def-async clear (collection-name)

    (const db (await this.db))
    (const transaction (.transaction db [collection-name] 'readwrite))
    (const object-store (.object-store transaction collection-name))
    (const cursor (.open-cursor object-store))
    (make-promise
     (def cursor.onsuccess (e)
       (const c e.target.result)
       (if c
           (then-do (.delete this [collection-name c.key])
                    (.continue c))
           (success)))))
  (def-async get ([collection-name  key])
    (const db (await this.db))
    (const transaction (.transaction db [collection-name] 'readwrite))
    (const object-store (.object-store transaction collection-name))
    (const request (.get object-store key))
    (make-promise
     (def request.onsuccess (event)
       (success event.result))
     (def request.onerror (event)
       (reject event))))
  (def-async delete ([collection-name  key])
    (const db (await this.db))
    (const transaction (.transaction db [collection-name] 'readwrite))
    (const object-store (.object-store transaction collection-name))
    (const request (.delete object-store key))
    (make-promise
     (def request.onsuccess (event)
       (success event.result))
     (def request.onerror (event)
       (reject event))))
  (def-async put (collection-name value)

    (const db (await this.db))
    (const transaction (.transaction db [collection-name] 'readwrite))
    (const object-store (.object-store transaction collection-name))
    (const request (.put object-store value))
    (make-promise
     (def request.onsuccess (event)
       (success event))
     (def request.onerror (event)
       (reject event))))
  (def-async start ()
    (const request (.open indexedDB this.name this.version))
    (def request.onupgradeneeded (e) (.upgrade this e.target.result))
    (make-promise
     (def request.onerror (e) (reject e))
     (def request.onsuccess (e)
       (.emit this.events 'start this.db)
       (success this)))))
(export Database)
