(import Interface "/shared/kit/interface/index.js")
(import Event-emitter "/shared/kit/events/index.js")
(def-lit-macro def-async (name args ...body)
  [" async "name  `(parenthetic (comma @args.contents))
            `(curly (do-block ...@body))])
(define Collection Interface
  (init (name database))
  (def *state-transaction ()
    )
  (def get (key))
  (def delete (key))
  (def set (key value)))

(define Database Interface

  (init (name (events ((create Event-emitter)))
              (writer-promises {})
              ))
  (cached db (.start this))
  (version 4)
  (collections [])

  (def add-collection (name)
    (if! (.includes this.collections name) (return))
    (.push this.collections name)
    )
  (def upgrade (db)
    (each this.collections (c)
          (if (not (.includes (Array.from db.object-store-names) c))
              (.create-object-store db c (lit (key-path 'save-index))))))
  (def remove-collection (name)

    (const names this.collection-names)
    (if! (not (.includes names name))
         (throw (new Error "Attempting to remove a collection that doesn't exist")))
    (.push names name)
    (assign this.collection-names names))
  (def-async* get-cursor (collection-name )

    (const db (await this.db))
    (const transaction (.transaction db [collection-name] 'readwrite))
    (const object-store (.object-store transaction collection-name))
    (const cursor (.open-cursor object-store))
    (var looping? true)
    (const get-next (-> (make-promise
                         (def cursor.onsuccess (e) (success e.target.result)))))
    (var p  (get-next))
    (while! true
            (const c (await p))
            (if! (not c)  break)
            (yield c)
            (assign p (get-next))
            (.continue c))
    null
    )

  (def-async clear (collection-name)

    (const db (await this.db))
    (const transaction (.transaction db [collection-name] 'readwrite))
    (const object-store (.object-store transaction collection-name))
    (const cursor (.open-cursor object-store))
    (make-promise
     (def cursor.onsuccess (e)
       (const c e.target.result)
       (if c
           (then-do (.delete this [collection-name c.key])
                    (.continue c))
           (success)))))
  (def-async get ([collection-name  key])
    (print "getting from db" this collection-name key)
    (const db (await this.db))
    (const transaction (.transaction db [collection-name] 'readonly))
    (const object-store (.object-store transaction collection-name))
    (const request (.get object-store key))
    (make-promise
     (def request.onsuccess (event)
       (print "gotten from db" event)
       (success event.target.result))
     (def request.onerror (event)
       (print "error!" event)
       (reject event))))
  (def-async delete ([collection-name  key])
    (const db (await this.db))
    (const transaction (.transaction db [collection-name] 'readwrite))
    (const object-store (.object-store transaction collection-name))
    (const request (.delete object-store key))
    (make-promise
     (def request.onsuccess (event)
       (success event.result))
     (def request.onerror (event)
       (reject event))))
  (def-async put (collection-name value)
    ;; (print "putting" value "in" collection-name)
    (set this.writer-promises collection-name
         (then-do (Promise.resolve (get this.writer-promises collection-name))
             (then this.db db
                   (const transaction (.transaction db [collection-name] 'readwrite))

                   (const object-store (.object-store transaction collection-name))
                   (const request (.put object-store value))
                   (make-promise
                    (var success? false)
                    (set-timeout (-> (if (not success?)
                                         (reject (new Error "Took too long."))))
                                 10000
                                 )
                    (def request.onsuccess (event)
                      (success event))
                    (def request.onerror (event)
                      (reject event)))))))
  (def-async start ()
    (const request (.open indexedDB this.name this.version))
    (const self this)
    (def request.onupgradeneeded (e) (.upgrade self e.target.result))
    (make-promise
     (def request.onerror (e) (reject e))
     (def request.onsuccess (e)
       (.emit self.events 'start e.target.result)
       (success e.target.result)))))
(export Database)
