(include "../../../headers/interface.sibilant")
(import-namespace interface)

(import List "../data-structures/list.js")
(import Spawnable "../data-structures/spawnable.js")

(define Group Spawnable
  (init ((*list (.spawn List))
         (*members (new Map))))

  (gett size this.*list.length)
  (gett length this.*list.length)
  (gett last this.*list.last)
  (def-generic clear (*list *members)
    (.clear *members)
    (.clear *list))

  (def create ()
    (doc-string "Shared.datastructures.Group.create" "no args" "Create an empty group instance")
    ((create this) (dots arguments)))

  (def of ((dots items))
    (doc-string "Shared.datastructures.Group.of" "[...items]" "Create a new group from a variable number of arguments, similar to `Array.of`.")
    (var list (List.from items))
    ((create this) list))

  (def-generic from (items (fn (=> (a) a)))
    (doc-string "Shared.datastructures.Group.from" "items" "Create a group from an iterable object after mapping its values.")
    (const list (List.from (.map (Array.from items) fn)))
    (const members (new Map))
    (each list (item node) (.set members item node))
    ((create this) list members))

  (def-generic pop (*list *members)
    (doc-string "Shared.datastructures.Group.pop" "*list *members" "Remove and return the element last in the group's ordering.")
    (collect item (.pop *list)
             ;; (print "Popping from group" item *list *members)

             (.delete *members item)))

  (def-generic push (value)
    (doc-string "Shared.datastructures.Group.push" "value" "Add an element to the end of the group's ordering.")
    )

  (def-generic each (f *list)
    (doc-string "Shared.datastructures.Group.each" "callback *list" "Call the given function on every element of the group and return the group.")
    (.each *list f)
    this)

  (def-generic find (f *list)
    (.find *list f))

  (def-generic add (member *list *members)
    (doc-string "Shared.datastructures.Group.add" "member" "Add a value to the group if it is not already present.")
    (unless ( *members.has member)
      (collect node (.node *list member)

               (.set *members member node)
               (.push-node *list node))))
  (def-generic reduce (f accumulator *list) (.reduce *list f accumulator))

  (def-generic has (member *members)
    (doc-string "Shared.datastructures.Group.has" "member" "Check if the group contains the given member and return a boolean.")

  (def-generic remove (member *list *members)
    (doc-string "Shared.datastructures.Group.remove" "member" "Remove a specific member from the group.")
    (collect node (.get *members member)
             (if node
                 (do (.remove-node *list node)
                  (.delete *members member))
                 (throw (new Error "Can't remove a member from a group they don't belong to"))
               ))))

(export Group)
)
